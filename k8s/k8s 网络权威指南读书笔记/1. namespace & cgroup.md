# linux 网络虚拟化

### linux namespace 机制

Linux Namespace 是 Linux 内核提供的一种资源隔离机制，它可以让进程拥有独立的系统资源视图，是容器技术的核心基础。

#### 🎯 什么是 Namespace？

**Namespace（命名空间）** 是 Linux 内核的一个特性，它将系统资源进行隔离，使得不同的进程组可以拥有独立的资源视图。每个 namespace 内的进程只能看到属于自己 namespace 的资源。

```
┌─────────────────────────────────────────┐
│            Host System                  │
├─────────────────┬───────────────────────┤
│   Namespace A   │     Namespace B       │
│                 │                       │
│   Process 1     │     Process 3         │
│   Process 2     │     Process 4         │
│                 │                       │
│   独立的资源视图 │     独立的资源视图     │
└─────────────────┴───────────────────────┘
```

#### 🗂️ Namespace 的类型

Linux 内核目前支持 8 种 namespace，它们在不同的内核版本中逐步引入：

##### 1. **PID Namespace (进程隔离)** - `Linux 2.6.24 (2008年)`
- **功能**: 隔离进程 ID 空间
- **特点**: 每个 PID namespace 有独立的进程号分配
- **应用**: 容器内进程 PID 从 1 开始
- **历史**: 最早引入的 namespace 之一，为容器技术奠定基础

```bash
# 查看当前进程的 PID namespace
ls -la /proc/self/ns/pid

# 创建新的 PID namespace
unshare --pid --fork --mount-proc /bin/bash

# 在新 namespace 中查看进程
ps aux  # 只能看到新 namespace 中的进程
```

**示例对比：**
```bash
# 主机系统
$ ps aux | head -3
USER    PID   %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root      1   0.0  0.1  77616  8964 ?     Ss   Jul28   0:01 /sbin/init
root      2   0.0  0.0      0     0 ?     S    Jul28   0:00 [kthreadd]

# 容器内（独立的 PID namespace）
$ ps aux | head -3
USER    PID   %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root      1   0.0  0.1  20312  3204 ?     Ss   10:30   0:00 /bin/bash
root     15   0.0  0.1  34400  2896 ?     R+   10:31   0:00 ps aux
```

##### 2. **Network Namespace (网络隔离)** - `Linux 2.6.24 (2008年)`
- **功能**: 隔离网络协议栈
- **包含**: 网络接口、路由表、防火墙规则、套接字等
- **应用**: 每个容器有独立的网络栈
- **历史**: 与 PID namespace 同期引入，使容器网络隔离成为可能

```bash
# 创建网络 namespace
ip netns add test-ns

# 查看 namespace 列表
ip netns list

# 在指定 namespace 中执行命令
ip netns exec test-ns ip addr show

# 创建 veth pair 连接不同 namespace
ip link add veth0 type veth peer name veth1
ip link set veth1 netns test-ns
```

**网络隔离示例：**
```bash
# 主机网络
$ ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast

# 新的网络 namespace（初始状态只有 lo 接口）
$ ip netns exec test-ns ip addr show
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN
```

##### 3. **Mount Namespace (文件系统隔离)** - `Linux 2.4.19 (2002年)`
- **功能**: 隔离文件系统挂载点
- **特点**: 每个 namespace 有独立的文件系统视图
- **应用**: 容器有独立的根文件系统
- **历史**: 最早的 namespace 实现，最初叫做 "mount namespace"

```bash
# 创建 mount namespace
unshare --mount /bin/bash

# 在新 namespace 中的挂载操作不影响主机
mount -t tmpfs tmpfs /tmp
```

##### 4. **UTS Namespace (UNIX Time-sharing System - 主机名隔离)** - `Linux 2.6.19 (2006年)`
- **功能**: 隔离主机名和域名
- **应用**: 容器可以有独立的主机名
- **全称**: UTS = UNIX Time-sharing System，历史上指代系统标识信息
- **历史**: 为容器提供独立的系统标识，增强隔离性

```bash
# 创建 UTS namespace
unshare --uts /bin/bash

# 修改主机名（只在当前 namespace 生效）
hostname container-host
```

##### 5. **IPC Namespace (Inter-Process Communication - 进程间通信隔离)** - `Linux 2.6.19 (2006年)`
- **功能**: 隔离 System V IPC 和 POSIX 消息队列
- **包含**: 消息队列、信号量、共享内存
- **全称**: IPC = Inter-Process Communication，进程间通信机制
- **历史**: 与 UTS namespace 同期引入，完善进程间隔离

```bash
# 创建 IPC namespace
unshare --ipc /bin/bash

# 查看 IPC 资源
ipcs -a
```

##### 6. **User Namespace (用户隔离)** - `Linux 3.8 (2013年)`
- **功能**: 隔离用户和组 ID
- **特点**: namespace 内的 root 不等于主机 root
- **安全**: 提供更好的权限隔离
- **历史**: 较晚引入的重要安全特性，使无特权容器成为可能

```bash
# 创建 user namespace
unshare --user --map-root-user /bin/bash

# 查看用户映射
cat /proc/self/uid_map
cat /proc/self/gid_map
```

##### 7. **Cgroup Namespace (控制组隔离)** - `Linux 4.6 (2016年)`
- **功能**: 隔离 cgroup 根目录视图
- **应用**: 容器看不到主机的 cgroup 层次结构
- **重要说明**: 这是一个特殊的 namespace，它隔离的是 cgroup 文件系统的视图，而不是 cgroup 的功能本身
- **历史**: 较新的安全增强特性，防止容器获取主机 cgroup 信息

#### 🔍 深入理解 Cgroup Namespace

**Cgroup Namespace** 是一个容易混淆的概念，让我们详细解释：

##### 📋 Cgroup Namespace vs Cgroup 功能

**关键区别:**
- **Cgroup 功能**: 资源限制和控制（CPU、内存、IO等）
- **Cgroup Namespace**: 隔离 `/proc/*/cgroup` 和 `/sys/fs/cgroup` 的视图

```bash
# 没有 Cgroup Namespace 时，容器内可以看到主机的完整 cgroup 层次
容器内执行: cat /proc/self/cgroup
输出: 12:memory:/docker/a1b2c3d4e5f6.../
     11:cpu:/docker/a1b2c3d4e5f6.../
     # 可以看到完整的主机 cgroup 路径

# 有 Cgroup Namespace 时，容器只看到相对路径
容器内执行: cat /proc/self/cgroup  
输出: 12:memory:/
     11:cpu:/
     # 看起来像是 cgroup 根目录
```

##### 🛠️ 实际操作演示

**创建 Cgroup Namespace:**
```bash
# 1. 创建带有 cgroup namespace 的环境
unshare --cgroup /bin/bash

# 2. 查看 cgroup 视图变化
echo "=== 主机视图 ==="
cat /proc/1/cgroup | head -3

echo "=== Namespace 内视图 ==="  
cat /proc/self/cgroup | head -3

# 3. 查看 /sys/fs/cgroup 的变化
ls -la /sys/fs/cgroup/
```

**对比效果:**
```bash
# 主机上的完整 cgroup 路径
主机: cat /proc/self/cgroup
12:memory:/user.slice/user-1000.slice/session-1.scope
11:cpu,cpuacct:/user.slice/user-1000.slice/session-1.scope

# Cgroup Namespace 内的相对路径  
容器: cat /proc/self/cgroup
12:memory:/
11:cpu,cpuacct:/
```

##### 🎯 为什么需要 Cgroup Namespace？

**1. 安全隔离**
```bash
# 防止容器获取主机 cgroup 信息
# 没有 cgroup namespace 时，恶意容器可能：
cat /proc/1/cgroup  # 看到主机进程的 cgroup 路径
ls /sys/fs/cgroup/memory/docker/  # 看到所有容器的 cgroup

# 有 cgroup namespace 后：
cat /proc/1/cgroup  # 只看到相对路径 "/"
ls /sys/fs/cgroup/memory/  # 看起来像是根 cgroup
```

**2. 信息泄露防护**
```bash
# 主机的 cgroup 路径可能泄露敏感信息
/sys/fs/cgroup/memory/docker/a1b2c3d4e5f6789.../
# 容器ID、主机架构等信息

# Cgroup namespace 隐藏了这些信息
/  # 只看到根路径
```

**3. 容器内程序兼容性**
```bash
# 某些程序会读取 /proc/self/cgroup 来判断运行环境
# 没有 cgroup namespace 时可能看到复杂的路径而出错
# 有了 cgroup namespace 后看到的是标准的根路径
```

##### 🔬 深度技术分析

**文件系统视图变化:**
```bash
# 主机上的实际 cgroup 层次结构
/sys/fs/cgroup/
├── memory/
│   ├── docker/
│   │   ├── container1.../
│   │   │   ├── memory.limit_in_bytes
│   │   │   └── tasks
│   │   └── container2.../
│   └── user.slice/
└── cpu/
    └── docker/
        └── container1.../

# Cgroup Namespace 内看到的虚拟层次结构
/sys/fs/cgroup/
├── memory/
│   ├── memory.limit_in_bytes  # 指向实际的容器 cgroup
│   └── tasks
└── cpu/
    ├── cpu.cfs_quota_us
    └── tasks
```

**内核实现原理:**
```bash
# 内核在 Cgroup Namespace 内重新映射路径
实际路径: /sys/fs/cgroup/memory/docker/a1b2c3d4.../memory.limit_in_bytes
虚拟路径: /sys/fs/cgroup/memory/memory.limit_in_bytes

# /proc/*/cgroup 文件内容也被重写
实际内容: 12:memory:/docker/a1b2c3d4e5f6.../
虚拟内容: 12:memory:/
```

##### 🧪 实践验证

**验证脚本:**
```bash
#!/bin/bash
echo "=== 验证 Cgroup Namespace 效果 ==="

# 1. 在主机上查看当前进程的 cgroup
echo "主机 cgroup 路径:"
cat /proc/self/cgroup | head -3

echo ""
echo "主机 cgroup 文件系统:"
ls -la /sys/fs/cgroup/ | head -5

# 2. 创建 cgroup namespace 并对比
echo ""
echo "创建 Cgroup Namespace..."
unshare --cgroup /bin/bash -c '
echo "Namespace 内 cgroup 路径:"
cat /proc/self/cgroup | head -3

echo ""
echo "Namespace 内 cgroup 文件系统:"
ls -la /sys/fs/cgroup/ | head -5

echo ""
echo "验证路径映射:"
echo "当前进程的内存限制文件:"
cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null || echo "文件不存在或无权限"
'
```

##### ⚠️ 注意事项和限制

**1. 功能限制**
```bash
# Cgroup Namespace 只隔离视图，不隔离功能
# 容器内的进程仍然受到主机设置的 cgroup 限制

# 容器内无法真正修改 cgroup 设置
echo "1G" > /sys/fs/cgroup/memory/memory.limit_in_bytes  # 通常会失败
```

**2. 兼容性问题**
```bash
# 某些监控工具可能不理解 cgroup namespace
# 需要更新工具以正确处理虚拟化的 cgroup 路径
```

**3. 调试困难**
```bash
# 在 cgroup namespace 内调试 cgroup 问题更困难
# 需要从主机角度查看真实的 cgroup 路径
```

##### 🐳 在容器技术中的应用

**Docker 中的使用:**
```bash
# Docker 可以选择是否启用 cgroup namespace
docker run --cgroupns=private nginx  # 启用 cgroup namespace
docker run --cgroupns=host nginx     # 使用主机 cgroup namespace

# 查看效果
docker exec container cat /proc/self/cgroup
```

**Kubernetes 中的应用:**
```yaml
# Kubernetes 1.25+ 支持 cgroup namespace
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  hostPID: false  # 确保 PID 隔离
  containers:
  - name: app
    image: nginx
    # cgroup namespace 通常自动启用
```

##### 📊 Cgroup Namespace vs 其他 Namespace

| Namespace类型 | 隔离对象 | 影响范围 | 安全收益 |
|---------------|----------|----------|----------|
| **PID** | 进程ID空间 | 进程可见性 | 高 |
| **Network** | 网络协议栈 | 网络访问 | 高 |
| **Mount** | 文件系统 | 文件访问 | 高 |
| **Cgroup** | Cgroup视图 | 系统信息 | 中等 |

**总结**: Cgroup Namespace 是一个"元隔离"机制，它隔离的是 cgroup 管理系统本身的视图，而不是被管理的资源。它提供了额外的安全层，防止容器获取主机的 cgroup 结构信息。

##### 8. **Time Namespace (时间隔离)** - `Linux 5.6 (2020年)`
- **功能**: 隔离系统时间
- **特点**: 较新的特性，支持独立的时钟设置
- **应用**: 允许容器有独立的时间视图，用于测试和模拟
- **历史**: 最新引入的 namespace，主要用于特殊测试场景

#### 📊 Namespace 发展时间线

```
2002  ┌─ Mount Namespace (Linux 2.4.19)
      │  └─ 最早的 namespace 实现
      │
2006  ├─ UTS + IPC Namespace (Linux 2.6.19)  
      │  └─ 主机名和进程间通信隔离
      │
2008  ├─ PID + Network Namespace (Linux 2.6.24)
      │  └─ 进程和网络隔离，容器技术关键里程碑
      │
2013  ├─ User Namespace (Linux 3.8)
      │  └─ 用户权限隔离，重大安全增强
      │
2016  ├─ Cgroup Namespace (Linux 4.6)
      │  └─ Cgroup 视图隔离
      │
2020  └─ Time Namespace (Linux 5.6)
         └─ 时间隔离，最新特性
```

#### 🎯 各版本的重要意义

**早期阶段 (2002-2008):**
- **Mount Namespace**: 奠定了资源隔离的基础
- **UTS/IPC Namespace**: 完善了基本的进程隔离
- **PID/Network Namespace**: 使真正的容器技术成为可能

**成熟阶段 (2008-2013):**
- 基础的容器隔离功能已经完备
- Docker (2013年) 正是基于这些 namespace 构建

**安全增强阶段 (2013-2020):**
- **User Namespace**: 解决了容器安全的核心问题
- **Cgroup Namespace**: 进一步增强了信息隔离
- **Time Namespace**: 为特殊应用场景提供支持

#### 🛠️ Namespace 操作命令

##### 基本命令工具
```bash
# unshare - 创建新的 namespace
unshare [options] [program [arguments]]

# nsenter - 进入已存在的 namespace  
nsenter [options] [program [arguments]]

# ip netns - 网络 namespace 专用工具
ip netns {add|del|list|exec} [arguments]
```

##### 常用操作示例
```bash
# 1. 创建包含多种 namespace 的环境
unshare --pid --net --mount --uts --ipc --fork /bin/bash

# 2. 查看进程的 namespace 信息
ls -la /proc/$PID/ns/

# 3. 进入指定进程的 namespace
nsenter --target $PID --pid --net --mount /bin/bash

# 4. 创建持久化的网络 namespace
ip netns add my-namespace
ip netns exec my-namespace /bin/bash
```

#### 🔍 Namespace 在容器中的应用

##### Docker 容器的 Namespace 使用
```bash
# 查看 Docker 容器使用的 namespace
docker run -d --name test-container nginx
docker inspect test-container | grep -i namespace

# 进入容器的 namespace
docker exec -it test-container /bin/bash

# 从主机进入容器的 namespace
PID=$(docker inspect -f '{{.State.Pid}}' test-container)
nsenter --target $PID --pid --net --mount /bin/bash
```

##### Kubernetes Pod 的 Namespace 共享
```yaml
# Pod 中的容器共享某些 namespace
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: container1
    image: nginx
  - name: container2  
    image: busybox
    command: ['sleep', '3600']
  # 两个容器共享：Network、IPC、UTS namespace
  # 独立：PID、Mount namespace（可配置）
```

#### 🔧 实践练习：创建完整的容器环境

##### 1. 手动创建类似容器的隔离环境
```bash
#!/bin/bash
# 创建完整的 namespace 隔离环境

# 1. 创建所有类型的 namespace
unshare --pid --net --mount --uts --ipc --user --map-root-user --fork /bin/bash -c '

# 2. 设置主机名
hostname my-container

# 3. 重新挂载 /proc（显示新的 PID namespace）
mount -t proc proc /proc

# 4. 创建网络接口
ip link add veth0 type veth peer name veth1

# 5. 配置网络
ip addr add 192.168.100.1/24 dev veth0
ip link set veth0 up
ip link set lo up

# 6. 启动 shell
exec /bin/bash
'
```

##### 2. 验证隔离效果
```bash
# 在新环境中验证各种隔离
echo "=== 进程隔离 ==="
ps aux  # 应该只看到少量进程

echo "=== 网络隔离 ==="  
ip addr show  # 应该只看到配置的接口

echo "=== 主机名隔离 ==="
hostname  # 应该显示 my-container

echo "=== 用户隔离 ==="
id  # 应该显示 uid=0(root)，但实际是映射的用户
```

#### 📊 Namespace 的层次结构

```
Host Namespace (最顶层)
├── PID 1 (init)
├── Container Namespace A
│   ├── PID 1 (容器进程)
│   ├── PID 2 (应用进程)
│   └── 独立的网络栈
└── Container Namespace B  
    ├── PID 1 (容器进程)
    ├── PID 2 (应用进程)
    └── 独立的网络栈
```

#### 🚨 注意事项和最佳实践

##### 1. **安全考虑**
```bash
# User namespace 映射要谨慎
echo "0 1000 1" > /proc/self/uid_map  # 将 root 映射到普通用户

# 避免特权容器共享主机 namespace
docker run --privileged  # 危险：绕过隔离
```

##### 2. **性能影响**
- namespace 切换有轻微性能开销
- 大量 namespace 会增加内存使用
- 网络 namespace 过多可能影响路由性能

##### 3. **调试技巧**
```bash
# 查看进程的所有 namespace
lsns -p $PID

# 比较两个进程的 namespace
lsns -p $PID1 > ns1.txt
lsns -p $PID2 > ns2.txt
diff ns1.txt ns2.txt
```

#### 🔗 与其他隔离技术的关系

| 技术 | 隔离级别 | 开销 | 安全性 |
|------|----------|------|--------|
| **Namespace** | 进程级 | 低 | 中等 |
| **虚拟机** | 系统级 | 高 | 高 |
| **Chroot** | 文件系统 | 很低 | 低 |
| **Cgroup** | 资源限制 | 低 | 中等 |

#### 🆚 Namespace vs Cgroup 详细对比

虽然 Namespace 和 Cgroup 都是容器技术的核心组件，但它们解决的是完全不同的问题：

##### 📋 核心功能对比

| 特性 | Namespace | Cgroup (Control Groups) |
|------|-----------|-------------------------|
| **主要作用** | **资源隔离** (看不到) | **资源限制** (用不完) |
| **解决问题** | "进程能看到什么资源" | "进程能使用多少资源" |
| **技术原理** | 虚拟化资源视图 | 限制和控制资源使用 |
| **典型应用** | 进程隔离、网络隔离 | CPU限制、内存限制 |

##### 🔍 具体功能差异

**Namespace（资源隔离）:**
```bash
# Namespace 让进程"看不到"其他资源
┌─────────────────────────┐  ┌─────────────────────────┐
│     Container A         │  │     Container B         │
│                         │  │                         │
│ 只能看到自己的:          │  │ 只能看到自己的:          │
│ • 进程列表              │  │ • 进程列表              │
│ • 网络接口              │  │ • 网络接口              │
│ • 文件系统              │  │ • 文件系统              │
│ • 主机名                │  │ • 主机名                │
└─────────────────────────┘  └─────────────────────────┘

# 验证 PID 隔离
主机: ps aux  # 看到所有进程
容器: ps aux  # 只看到容器内进程
```

**Cgroup（资源限制）:**
```bash
# Cgroup 限制进程"能用多少"资源
┌─────────────────────────────────────────┐
│                Host                     │
│  总资源: CPU 8核, 内存 16GB            │
├─────────────────┬───────────────────────┤
│   Container A   │     Container B       │
│                 │                       │
│   限制为:       │     限制为:           │
│   • CPU: 2核    │     • CPU: 1核        │
│   • 内存: 4GB   │     • 内存: 2GB       │
│   • 磁盘IO限制  │     • 网络带宽限制    │
└─────────────────┴───────────────────────┘
```

##### 🛠️ 实际操作对比

**Namespace 操作示例:**
```bash
# 创建网络隔离
ip netns add container-a
ip netns exec container-a ip addr show  # 独立的网络视图

# 创建 PID 隔离  
unshare --pid --fork --mount-proc /bin/bash
ps aux  # 看到的是隔离后的进程列表

# 创建文件系统隔离
unshare --mount /bin/bash
mount -t tmpfs tmpfs /tmp  # 只影响当前 namespace
```

**Cgroup 操作示例:**
```bash
# 创建 CPU 限制
mkdir /sys/fs/cgroup/cpu/my-container
echo "50000" > /sys/fs/cgroup/cpu/my-container/cpu.cfs_quota_us  # 限制为0.5核
echo $$ > /sys/fs/cgroup/cpu/my-container/tasks

# 创建内存限制
mkdir /sys/fs/cgroup/memory/my-container  
echo "512M" > /sys/fs/cgroup/memory/my-container/memory.limit_in_bytes
echo $$ > /sys/fs/cgroup/memory/my-container/tasks

# 验证限制生效
cat /proc/self/cgroup  # 查看当前进程的 cgroup
```

##### 📊 资源管理方式对比

**Namespace（视图隔离）:**
```
进程A 看到的系统资源:
├── 网络接口: eth0 (10.1.1.100)
├── 进程列表: PID 1, 2, 3
└── 文件系统: /app, /tmp, /var

进程B 看到的系统资源:  
├── 网络接口: eth0 (10.1.2.100)  # 不同的IP
├── 进程列表: PID 1, 2, 3        # 不同的进程
└── 文件系统: /web, /tmp, /var    # 不同的挂载点

实际物理资源是共享的，但逻辑视图是隔离的
```

**Cgroup（配额限制）:**
```
物理服务器资源:
├── CPU: 8核心 100%
├── 内存: 16GB  
└── 磁盘IO: 1000 IOPS

分配给容器的配额:
├── 容器A: CPU 25%(2核), 内存 4GB, IO 300 IOPS
├── 容器B: CPU 12.5%(1核), 内存 2GB, IO 200 IOPS  
└── 剩余: CPU 62.5%(5核), 内存 10GB, IO 500 IOPS
```

##### 🎯 应用场景对比

**使用 Namespace 的场景:**
```bash
# 1. 多租户隔离
# 不同客户的应用不能看到彼此的进程和网络

# 2. 开发环境隔离
# 开发、测试、生产环境有独立的网络和文件系统视图

# 3. 安全隔离
# 恶意进程无法看到和访问其他容器的资源
```

**使用 Cgroup 的场景:**
```bash
# 1. 防止资源滥用
# 限制单个容器不能占用超过分配的CPU和内存

# 2. 保证服务质量  
# 关键业务应用获得足够的资源保证

# 3. 成本控制
# 根据付费等级限制资源使用量
```

##### 🔄 两者结合使用

在容器技术中，Namespace 和 Cgroup 通常配合使用：

```yaml
# Docker 容器配置示例
version: '3'
services:
  web-app:
    image: nginx
    # Namespace 隔离配置
    network_mode: "bridge"    # 独立网络 namespace
    pid: "container:app"      # 共享 PID namespace
    
    # Cgroup 资源限制配置  
    deploy:
      resources:
        limits:
          cpus: '0.5'         # CPU 限制
          memory: 512M        # 内存限制
        reservations:
          cpus: '0.25'        # CPU 预留
          memory: 256M        # 内存预留
```

**在 Kubernetes 中的体现:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
  - name: app
    image: nginx
    # Cgroup 资源限制
    resources:
      limits:
        cpu: "500m"      # 0.5 CPU 核心
        memory: "512Mi"  # 512 MB 内存
      requests:
        cpu: "250m"      # 请求 0.25 CPU
        memory: "256Mi"  # 请求 256 MB 内存
    
    # Namespace 隔离（K8s 自动管理）
    # - Pod 内容器共享 Network/IPC/UTS namespace
    # - 每个容器有独立的 Mount/PID namespace
```

##### 🚨 故障排查差异

**Namespace 相关问题:**
```bash
# 问题：容器无法访问外部网络
# 排查：检查网络 namespace 配置
ip netns exec container-ns ip route show
ip netns exec container-ns ping 8.8.8.8

# 问题：进程看不到预期的文件
# 排查：检查 mount namespace
mount | grep container
ls -la /proc/self/ns/mnt
```

**Cgroup 相关问题:**
```bash
# 问题：应用性能慢
# 排查：检查 CPU/内存限制
cat /sys/fs/cgroup/cpu/docker/container-id/cpu.stat
cat /sys/fs/cgroup/memory/docker/container-id/memory.usage_in_bytes

# 问题：进程被 OOM Kill
# 排查：检查内存限制设置
dmesg | grep -i "killed process"
cat /sys/fs/cgroup/memory/docker/container-id/memory.limit_in_bytes
```

##### 📈 性能影响对比

| 操作类型 | Namespace 开销 | Cgroup 开销 |
|----------|----------------|-------------|
| **创建销毁** | 很低 | 很低 |
| **切换上下文** | 低 | 几乎无 |
| **运行时监控** | 几乎无 | 低 |
| **资源统计** | 无 | 低 |

**总结**: Namespace 负责"隔离视图"，Cgroup 负责"限制使用"，两者结合才能实现完整的容器化！

Namespace 提供了在性能和隔离性之间的良好平衡，是现代容器技术不可或缺的基础设施。